# Composable AI Advisors - Cursor Rules

## Project Overview

This is the **Composable AI Advisors** project, a multi-agent mesh architecture system that uses:
- **Orchestration**: General-purpose LLM constrained by models (bow-tie pattern) that decomposes tasks and coordinates specialists
- **Domain Models**: Static, machine-readable model descriptions (Turtle/JSON/Markdown) that LLMs use to assume stakeholder positions
- **MCP (Model Context Protocol)**: Protocol for secure context exchange, provenance, and audit
- **Spores**: Portable context/prompt bundles for multi-agent continuity
- **RDF/Turtle Ontologies**: Semantic web standards for structured data

## Architecture Principles

1. **Multi-Agent Mesh**: Decompose general AI into a service-mesh of specialized reasoning engines
2. **MaaS (Models as a Service)**: Each specialist reasoner runs as its own service/API
3. **Orchestration**: General LLM coordinates domain-specific services
4. **Context Exchange**: Use MCP for secure context, tools, and traceability
5. **Ontology-Driven**: Use RDF/Turtle for structured, interoperable data

## Key Terminology

Refer to `internal-lingo-cheatsheet.md` for full glossary. Key terms:
- **LIM42**: Design-scaffolding workflow toolset
- **BFG9K**: Agent-orchestration framework (separate product/repo, not part of this architecture)
- **Spore/ContextSpore/PromptSpore**: Modular, reusable context/prompt packets
- **MCP**: Model Context Protocol for agent communication
- **Mesh**: Network of specialist reasoning services

## Development Guidelines

### Code Organization

- **Backend**: FastAPI service in `backend/` - handles RDF processing, API endpoints, Gemini AI integration
- **Frontend**: React app in `frontend/` - UI for visualizing PoDs, Spores, and relationships
- **Ontologies**: RDF/Turtle files at root (`*.ttl`) - semantic data definitions
- **Documentation**: Markdown files for architecture, deployment, and project info

### RDF/Turtle Conventions

- Use namespaces defined in `caa-glossary.ttl`
- Follow ontology patterns from existing `.ttl` files
- Maintain semantic relationships and provenance
- See `.cursor/rules/ontology.mdc` for detailed conventions

### MCP Integration

- MCP configuration will be in `.mcp/` directory (to be added)
- Context exchange follows MCP protocol specifications
- Tool adapters connect reasoning agents to concrete tools/APIs
- Maintain traceability and audit trails

### Multi-Agent Patterns

- Design services as independent, orchestrated components
- Use Spores for context continuity across agent sessions
- Follow service mesh patterns (not monolithic architecture)
- Each domain model should expose clear API boundaries

## File-Specific Rules

### Python (Backend)
- Use FastAPI for API endpoints
- RDFLib for RDF/Turtle processing
- Follow PEP 8 style guidelines
- Type hints recommended

### JavaScript/React (Frontend)
- React 18.2+ patterns
- Axios for API calls
- Modern ES6+ syntax
- Component-based architecture

### RDF/Turtle Files
- Follow existing namespace conventions
- Use SHACL shapes for validation (see `caa-glossary.ttl`)
- Maintain ontology relationships
- Document new classes/properties

## When Making Changes

1. **Check Architecture**: Ensure changes align with multi-agent mesh pattern
2. **Update Ontologies**: If adding new concepts, update relevant `.ttl` files
3. **Maintain MCP Compatibility**: Consider context exchange implications
4. **Preserve Spore Patterns**: Maintain context continuity mechanisms
5. **Document Changes**: Update relevant `.md` files

## Reference Files

- `agents.md` - Comprehensive AI agent guidance
- `internal-lingo-cheatsheet.md` - Terminology glossary
- `caa-glossary.ttl` - Core ontology definitions
- `ARCHITECTURE.md` - System architecture details
- `.cursor/rules/*.mdc` - Detailed rule sets (architecture, ontology, MCP, coding standards, tooling)
  - See `.cursor/rules/tooling.mdc` for deterministic tooling rules (no heuristic editing)

## Operational Editing Policy
- All changes must be applied via git commits on a feature branch and merged by PR.
- Do not require inline editor approvals for changes; avoid heuristic patching in favor of scripted/tool-driven edits.

## Spec-Driven Development Gate (MANDATORY)
- Requirements and design are authoritative in `.kiro/specs/`.
- Before any analysis, implementation, or readiness assessment:
  1) Open and review the relevant `requirements.md`, `design.md`, and `tasks.md` under `.kiro/specs/{domain-model-framework|mcp-implementation|orchestrator-service}/`
  2) Map intended changes to explicit requirement IDs and acceptance criteria
  3) Note “Spec Coverage” in status updates listing the reviewed spec files/sections
- Do not proceed if this gate is not satisfied. Escalate if spec sections are missing or ambiguous.

## Spec Tooling (cc-sdd) — REQUIRED
- You MUST use cc-sdd tools to manage specs and traceability.
- For every change set:
  - Run cc-sdd coverage to enumerate affected requirements (IDs) and attach the artifact.
  - Run cc-sdd mapping to link changes to requirements and acceptance criteria.
  - Validate and sync `.kiro/specs` using cc-sdd before implementation.
- Status notes MUST include cc-sdd coverage/mapping references and requirement IDs.

## Important Notes

- The current README.md is hackathon-focused and may not reflect current project state
- MCP configuration will be added separately
- This project emphasizes composability and modularity over monolithic design
- Always consider multi-agent coordination when designing features

